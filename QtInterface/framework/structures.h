#ifndef STRUCTURES_H
#define STRUCTURES_H

#include <QDebug>
#include <QString>
#include <vector>
#include <QDateTime>
#include <QStringList>
#include <QMap>

#define DISPLAY_TESTING_FEATURES false
#define MINUTES_BEFORE_RES_ALERT 10
#define MINUTES_TIME_BUFFER 30
#define DATETIME_FORMAT "dd/MM/yyyy h:mm AP"
#define DB_TIME_INDEX "dd/MM/yyyy"

// Small things that get coupled with reservables, but aren't kept track of
struct peripherals {
    QString name, desc;
    int count, numberpresent;

    peripherals& operator=(const peripherals &other)
    {
        name = other.name; desc = other.desc; count = other.count;
        numberpresent = other.numberpresent;
        return *this;
    }

    bool operator==(const peripherals &other)
    {
        return (name == other.name);
    }

    QString exportJson()
    {
        return "{\"name\": \""+ name + "\"," +
                "\"desc\": \""+ desc + "\"," +
                "\"count\": "+ QString::number(count) + "," +
                "\"numberpresent\": "+ QString::number(numberpresent) + "}";
    }
};

// Valuable things that are reserverd
struct reservableItems {
    // Schedule id ties to schedule item to track usability
    QString barcode, name, desc;
    std::vector<peripherals> periphs;

    reservableItems& operator=(const reservableItems &other)
    {
        barcode = other.barcode; name = other.name; desc = other.desc;
        periphs = other.periphs;
        return *this;
    }


    bool operator==(const QString &other)
    {
        return (name == other || barcode == other);
    }

    QString compilePeriphs()
    {
        QString result;
        for(auto i = periphs.begin(); i != periphs.end(); ++i)
        {
            result = result + (*i).exportJson() + ",";
        }
        result = result.mid(0, result.length()-1);
        return result;
    }

    QString exportJson()
    {
        return "{\"barcode\": \"" + barcode + "\"," +
                "\"name\": \"" + name + "\"," +
                "\"desc\": \"" + desc + "\"," +
                "\"periphs\": [" + compilePeriphs() + "]}";
    }
};

// Item schedule info
struct scheduleEntry{
    QString sid, start, end, resid;
    scheduleEntry(){}
    scheduleEntry& operator=(const scheduleEntry &other)
    {
        sid = other.sid; start = other.start; end = other.end;
        resid = other.resid;
        return *this;
    }
};

enum class ScheduleConflictTypes{
    startTimeOverlap,
    endTimeOverlap,
    invalidReservationTime

};

// A report of conflict generated by an item's schedule structure
struct scheduleConflict{
    bool exists;
    QString itembarcode;
    QDateTime requestedStart, requestedEnd;
    scheduleEntry conflict;
    ScheduleConflictTypes conflictType;
    qint64 secondsTo;

    // If no conflict, just return no conflcit
    scheduleConflict()
    {
        exists = false;
    }

    scheduleConflict& operator=(const scheduleConflict &other)
    {
        exists = other.exists; itembarcode = other.itembarcode;
        conflict = other.conflict; conflictType = other.conflictType;
        secondsTo = other.secondsTo;
        return *this;
    }

    scheduleConflict(QString item, QDateTime rstart,
                     QDateTime rend, scheduleEntry entry, ScheduleConflictTypes ctype)
    {
        exists = true;
        itembarcode = item; requestedStart = rstart; requestedEnd = rend;
        conflict = entry; conflictType = ctype;

        if (ctype == ScheduleConflictTypes::endTimeOverlap)
        {
            secondsTo = rstart.secsTo(
                        QDateTime::fromString(conflict.start, QString(DATETIME_FORMAT)));
        }
        else
            secondsTo = 0;
    }

};

// The item's schedule
struct schedule{
    QString scheduleid; // Same as an item's barcode
    std::vector<scheduleEntry> scheduleInformation;

    schedule& operator=(const schedule &other)
    {
        scheduleid = other.scheduleid;
        scheduleInformation = other.scheduleInformation;
        return *this;
    }

    // Go through the item's schedule and check for conflicting datetime
    scheduleConflict checkForConflict(QString start, QString end)
    {
        QDateTime dt_start = QDateTime::fromString(start, QString(DATETIME_FORMAT));
        QDateTime dt_end = QDateTime::fromString(end, QString(DATETIME_FORMAT));


        if(dt_start >= dt_end)
        {
            return scheduleConflict(scheduleid, dt_start, dt_end,
                                    scheduleEntry(), ScheduleConflictTypes::invalidReservationTime);
        }


        for(auto i = scheduleInformation.begin(); i!= scheduleInformation.end(); ++i)
        {
            QDateTime dummy_start = QDateTime::fromString((*i).start, QString(DATETIME_FORMAT));
            QDateTime dummy_end = QDateTime::fromString((*i).end, QString(DATETIME_FORMAT));

/*
            qDebug() << "\n\nRequested Reservation Start: " << start << ". " << dt_start.isValid();
            qDebug() << "Requested Reservation End: " << end << ". " << dt_end.isValid();
            qDebug() << "'OTHER' Reservation Start: " << (*i).start << ". " << dummy_start.isValid();
            qDebug() << "'OTHER' Reservation End: " << (*i).end << ". " << dummy_end.isValid();
*/

            // Ensure that the item is available before the reservaion by 'MINUTES_TIME_BUFFER' minutes
            dummy_start.addSecs(MINUTES_TIME_BUFFER * 60);

            if(dt_start >= dummy_start && dt_start <= dummy_end)
            {
                qDebug() << "CONFLICT:startTimeOverlap " << "REQSTART: " << start <<
                            "DUMMYSTART " << (*i).start << " DUMMY END " << (*i).end;

                return scheduleConflict(scheduleid, dummy_start, dummy_end,
                                        (*i), ScheduleConflictTypes::startTimeOverlap);
            }
            if(dt_start < dummy_start && dt_end > dummy_start)
            {
                qDebug() << "CONFLICT:endTimeOverlap " << "REQSTART: " << start <<
                            "REQEND: " << end <<
                            "DUMMYSTART " << (*i).start << " DUMMY END " << (*i).end;
                return scheduleConflict(scheduleid, dummy_start, dummy_end,
                                        (*i), ScheduleConflictTypes::endTimeOverlap);
            }
        }

        scheduleConflict availableItem;
        availableItem.itembarcode = scheduleid;
        availableItem.exists = false;
        return availableItem;
    }
};

// Reservation structure
struct reservations {
    QString id, ti, title, created, wfor, by,
                start, end, status, retby, email;
    QStringList itemBarcodes;

    QString compileItemBarcodes()
    {
        QString result;
        foreach(QString item, itemBarcodes)
        {
            result = result +
                    "\"" + item + "\",";
        }
        result = result.mid(0, result.length()-1);
        return result;
    }

    QString exportJson()
    {
        return "{\"id\": \"" + id +
                "\", \"ti\":\"" + ti + "\"," +
                " \"title\": \"" + title + "\"," +
                " \"created\":\""+ created + "\", " +
                " \"wfor\": \""+ wfor + "\", " +
                " \"by\": \""+ by + "\", " +
                " \"start\": \""+ start + "\", " +
                " \"end\": \""+ end + "\", " +
                " \"status\": \""+ status + "\", " +
                " \"retby\": \""+ retby + "\", " +
                " \"email\": \""+ email + "\", " +
                " \"itemBarcodes\":["+ compileItemBarcodes() + "]}";
    }
};

// Reminders!
struct reservedReminders {
    QString id, ti,title, created, desc, start, end, by, status;
};

// Categories
struct itemCategories {
    QString id, label, parent;
    QStringList barcodes;
};

// Campus Buildings
struct buildings {
    QStringList names;
    QMap<QString, QStringList> nameToRoomsMap;
};

// Repeating reservations / reminders
enum class repititionType{
    M, T, W, R, F, S, Su
};
enum class repititionFrequency{
    once, weekly, biweekly, monthly, yearly
};
enum class repititionMarker{
    reminder, reservation
};

struct repetition {
    repititionType repType;
    repititionMarker repMarker;
    repititionFrequency repFreq;
    QString repid, firstOccurrence, lastOccurrence, status;
    QStringList chainedIDS;

    // This isn't stored in the DB explicitly, but built by IDS
    // when the repitition object is requested
    std::vector<reservations> chainedReservations;
    std::vector<reservedReminders> chainedReminders;

    repetition& operator=(const repetition &other)
    {
        repid = other.repid; firstOccurrence = other.firstOccurrence; lastOccurrence = other.lastOccurrence;
        chainedIDS = other.chainedIDS; repType = other.repType;
        repFreq = other.repFreq; status = other.status;
        return *this;
    }

    repetition(){}

    // For constructing already generated repitions from a data stream (LIKE DAM!)
    repetition(repititionType rt, repititionMarker ma, repititionFrequency rfm, QString rid, QString fo, QString lo, QString stat, QStringList crids)
    {
        repType = rt; repFreq = rfm; repid = rid; firstOccurrence = fo;
        repMarker = ma; lastOccurrence = lo; status = stat;
        chainedIDS = crids;
    }
};

struct timespecificItems{
    // Item name -> definition
    QMap<QString, reservableItems> availableItems;
    QMap<QString, reservableItems> unAvailableItems;
    QMap<QString, reservableItems> schedAvail;
    QMap<QString, reservableItems> schedUnavail;
    bool inited;

    timespecificItems(){
        inited = false;
    }
    timespecificItems(std::vector<reservableItems> available, std::vector<reservableItems> unavailable,
                      std::vector<schedule> availScheds, std::vector<schedule> unavailScheds)
    {
        for(auto i = available.begin(); i != available.end(); ++i)
            availableItems.insert((*i).name, (*i));
        for(auto i = unavailable.begin(); i != unavailable.end(); ++i)
            unAvailableItems.insert((*i).name, (*i));
        for(auto i = availScheds.begin(); i != availScheds.end(); ++i)
            schedAvail.insert((*i).scheduleid, (*i));
        for(auto i = unavailScheds.begin(); i != unavailScheds.end(); ++i)
            schedUnavail.insert((*i).scheduleid, (*i));
        inited = true;
    }
    timespecificItems& operator=(const timespecificItems &other)
    {
        availableItems = other.availableItems;
        unAvailableItems = other.unAvailableItems;
        schedAvail = other.schedAvail; schedUnavail = other.schedUnavail;
        inited = true;
        return *this;
    }
    void clear()
    {
        availableItems.clear();
        unAvailableItems.clear();
        inited = false;
    }
};

#endif // STRUCTURES_H
