#ifndef STRUCTURES_H
#define STRUCTURES_H

#include <QString>
#include <vector>
#include <QDateTime>
#include <QStringList>
#include <QMap>

#define DATETIME_FORMAT "hh:mm. ddd MMMM d yy"

// Small things that get coupled with reservables, but aren't kept track of
struct peripherals {
    QString name, desc;
    int count, numberpresent;

    peripherals& operator=(const peripherals &other)
    {
        name = other.name; desc = other.desc; count = other.count;
        numberpresent = other.numberpresent;
        return *this;
    }

    bool operator==(const peripherals &other)
    {
        return (name == other.name);
    }
};

// Valuable things that are reserverd
struct reservableItems {
    // Schedule id ties to schedule item to track usability
    QString barcode, name, desc;
    std::vector<peripherals> periphs;

    reservableItems& operator=(const reservableItems &other)
    {
        barcode = other.barcode; name = other.name; desc = other.desc;
        periphs = other.periphs;
        return *this;
    }
};

// Item schedule info
struct scheduleEntry{
    QString sid, start, end, resid;
    scheduleEntry& operator=(const scheduleEntry &other)
    {
        sid = other.sid; start = other.start; end = other.end;
        resid = other.resid;
        return *this;
    }
};

enum class ScheduleConflictTypes{
    startTimeOverlap,
    endTimeOverlap
};


// A report of conflict generated by an item's schedule structure
struct scheduleConflict{
    bool exists;
    QString itembarcode;
    QDateTime requestedStart, requestedEnd;
    scheduleEntry conflict;
    ScheduleConflictTypes conflictType;
    qint64 secondsTo;

    // If no conflict, just return no conflcit
    scheduleConflict()
    {
        exists = false;
    }

    scheduleConflict(QString item, QDateTime rstart,
                     QDateTime rend, scheduleEntry entry, ScheduleConflictTypes ctype)
    {
        exists = true;
        itembarcode = item; requestedStart = rstart; requestedEnd = rend;
        conflict = entry; conflictType = ctype;

        if (ctype == ScheduleConflictTypes::endTimeOverlap)
        {
            secondsTo = rstart.secsTo(
                        QDateTime::fromString(conflict.start, QString(DATETIME_FORMAT)));
        }
        else
            secondsTo = 0;
    }

};

// The item's schedule
struct schedule{
    QString scheduleid; // Same as an item's barcode
    std::vector<scheduleEntry> scheduleInformation;

    schedule& operator=(const schedule &other)
    {
        scheduleid = other.scheduleid;
        scheduleInformation = other.scheduleInformation;
        return *this;
    }

    // Go through the item's schedule and check for conflicting datetime
    scheduleConflict checkForConflict(QString start, QString end)
    {
        QDateTime dt_start = QDateTime::fromString(start, QString(DATETIME_FORMAT));
        QDateTime dt_end = QDateTime::fromString(end, QString(DATETIME_FORMAT));

        for(auto i = scheduleInformation.begin(); i!= scheduleInformation.end(); ++i)
        {
            QDateTime dummy_start = QDateTime::fromString((*i).start, QString(DATETIME_FORMAT));
            QDateTime dummy_end = QDateTime::fromString((*i).end, QString(DATETIME_FORMAT));
            if(dt_start >= dummy_start && dt_start <= dummy_end)
            {
                return scheduleConflict(scheduleid, dummy_start, dummy_end,
                                        (*i), ScheduleConflictTypes::startTimeOverlap);
            }
            if(dt_start < dummy_start && dt_end > dummy_end)
            {
                return scheduleConflict(scheduleid, dummy_start, dummy_end,
                                        (*i), ScheduleConflictTypes::endTimeOverlap);
            }
        }
        return scheduleConflict();
    }
};

// Reservation structure
struct reservations {
    QString id, ti, title, created, wfor, by, start, end, status;
    QStringList itemBarcodes;
};

// Reminders!
struct reservedReminders {
    QString id, ti,title, created, desc, start, end, by, status;
};

// Categories
struct itemCategories {
    QString id, label, parent;
    QStringList barcodes;
};

// Campus Buildings
struct buildings {
    QStringList names;
    QMap<QString, QStringList> nameToRoomsMap;
};



#endif // STRUCTURES_H
