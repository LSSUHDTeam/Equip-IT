#ifndef STRUCTURES_H
#define STRUCTURES_H

#include <QDebug>
#include <QString>
#include <vector>
#include <QDateTime>
#include <QStringList>
#include <QMap>

#define MINUTES_BEFORE_RES_ALERT 10
#define MINUTES_TIME_BUFFER 30
#define DATETIME_FORMAT "dd/MM/yyyy h:mm AP"

// Small things that get coupled with reservables, but aren't kept track of
struct peripherals {
    QString name, desc;
    int count, numberpresent;

    peripherals& operator=(const peripherals &other)
    {
        name = other.name; desc = other.desc; count = other.count;
        numberpresent = other.numberpresent;
        return *this;
    }

    bool operator==(const peripherals &other)
    {
        return (name == other.name);
    }
};

// Valuable things that are reserverd
struct reservableItems {
    // Schedule id ties to schedule item to track usability
    QString barcode, name, desc;
    std::vector<peripherals> periphs;

    reservableItems& operator=(const reservableItems &other)
    {
        barcode = other.barcode; name = other.name; desc = other.desc;
        periphs = other.periphs;
        return *this;
    }
};

// Item schedule info
struct scheduleEntry{
    QString sid, start, end, resid;
    scheduleEntry& operator=(const scheduleEntry &other)
    {
        sid = other.sid; start = other.start; end = other.end;
        resid = other.resid;
        return *this;
    }
};

enum class ScheduleConflictTypes{
    startTimeOverlap,
    endTimeOverlap,

};

// A report of conflict generated by an item's schedule structure
struct scheduleConflict{
    bool exists;
    QString itembarcode;
    QDateTime requestedStart, requestedEnd;
    scheduleEntry conflict;
    ScheduleConflictTypes conflictType;
    qint64 secondsTo;

    // If no conflict, just return no conflcit
    scheduleConflict()
    {
        exists = false;
    }

    scheduleConflict& operator=(const scheduleConflict &other)
    {
        exists = other.exists; itembarcode = other.itembarcode;
        conflict = other.conflict; conflictType = other.conflictType;
        secondsTo = other.secondsTo;
        return *this;
    }

    scheduleConflict(QString item, QDateTime rstart,
                     QDateTime rend, scheduleEntry entry, ScheduleConflictTypes ctype)
    {
        exists = true;
        itembarcode = item; requestedStart = rstart; requestedEnd = rend;
        conflict = entry; conflictType = ctype;

        if (ctype == ScheduleConflictTypes::endTimeOverlap)
        {
            secondsTo = rstart.secsTo(
                        QDateTime::fromString(conflict.start, QString(DATETIME_FORMAT)));
        }
        else
            secondsTo = 0;
    }

};

// The item's schedule
struct schedule{
    QString scheduleid; // Same as an item's barcode
    std::vector<scheduleEntry> scheduleInformation;

    schedule& operator=(const schedule &other)
    {
        scheduleid = other.scheduleid;
        scheduleInformation = other.scheduleInformation;
        return *this;
    }

    // Go through the item's schedule and check for conflicting datetime
    scheduleConflict checkForConflict(QString start, QString end)
    {
        QDateTime dt_start = QDateTime::fromString(start, QString(DATETIME_FORMAT));
        QDateTime dt_end = QDateTime::fromString(end, QString(DATETIME_FORMAT));

        qDebug() << "END TIME : " << end;

        for(auto i = scheduleInformation.begin(); i!= scheduleInformation.end(); ++i)
        {
            QDateTime dummy_start = QDateTime::fromString((*i).start, QString(DATETIME_FORMAT));
            QDateTime dummy_end = QDateTime::fromString((*i).end, QString(DATETIME_FORMAT));

            // Ensure that the item is available before the reservaion by 'MINUTES_TIME_BUFFER' minutes
            dummy_start.addSecs(MINUTES_TIME_BUFFER * 60);

            if(dt_start >= dummy_start && dt_start <= dummy_end)
            {
                qDebug() << "CONFLICT:startTimeOverlap " << "REQSTART: " << start <<
                            "DUMMYSTART " << (*i).start << " DUMMY END " << (*i).end;

                return scheduleConflict(scheduleid, dummy_start, dummy_end,
                                        (*i), ScheduleConflictTypes::startTimeOverlap);
            }
            if(dt_start < dummy_start && dt_end > dummy_end)
            {
                qDebug() << "CONFLICT:endTimeOverlap " << "REQSTART: " << start <<
                            "REQEND: " << end <<
                            "DUMMYSTART " << (*i).start << " DUMMY END " << (*i).end;
                return scheduleConflict(scheduleid, dummy_start, dummy_end,
                                        (*i), ScheduleConflictTypes::endTimeOverlap);
            }
        }
        return scheduleConflict();
    }
};

// Reservation structure
struct reservations {
    QString id, ti, title, created, wfor, by,
                start, end, status, retby, email;
    QStringList itemBarcodes;
};

// Reminders!
struct reservedReminders {
    QString id, ti,title, created, desc, start, end, by, status;
};

// Categories
struct itemCategories {
    QString id, label, parent;
    QStringList barcodes;
};

// Campus Buildings
struct buildings {
    QStringList names;
    QMap<QString, QStringList> nameToRoomsMap;
};

// Repeating reservations / reminders
enum class repititionType{
    M, T, W, R, F, S, Su
};
enum class repititionFrequency{
    once, weekly, biweekly, monthly, yearly
};
enum class repititionMarker{
    reminder, reservation
};

struct repetition {
    repititionType repType;
    repititionMarker repMarker;
    repititionFrequency repFreq;
    QString repid, firstOccurrence, lastOccurrence, status;
    QStringList chainedIDS;

    // This isn't stored in the DB explicitly, but built by IDS
    // when the repitition object is requested
    std::vector<reservations> chainedReservations;
    std::vector<reservedReminders> chainedReminders;

    repetition& operator=(const repetition &other)
    {
        repid = other.repid; firstOccurrence = other.firstOccurrence; lastOccurrence = other.lastOccurrence;
        chainedIDS = other.chainedIDS; repType = other.repType;
        repFreq = other.repFreq; status = other.status;
        return *this;
    }

    repetition(){}

    // For constructing already generated repitions from a data stream (LIKE DAM!)
    repetition(repititionType rt, repititionMarker ma, repititionFrequency rfm, QString rid, QString fo, QString lo, QString stat, QStringList crids)
    {
        repType = rt; repFreq = rfm; repid = rid; firstOccurrence = fo;
        repMarker = ma; lastOccurrence = lo; status = stat;
        chainedIDS = crids;
    }
};


#endif // STRUCTURES_H
